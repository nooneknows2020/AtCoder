# AtCoderのためのC++入門

## 目次

- [第1章:基本文法](#第1章基本文法)
  - 出力とコメント
  - プログラムの書き方
  - プログラムのエラー
  - 四則演算と優先順位
  - 変数と型
  - プログラムの実行順序と入力
  - if文、比較演算子、論理演算子
  - 条件式の結果とbool型
  - 変数のスコープ
  - 複合代入演算子
  - while文
  - for文、break、continue
  - 文字列と文字
  - 配列
  - 組み込み関数(STL)
  - 関数の定義と使用
- 第2章:複雑な計算処理の書き方
  - ループの書き方と範囲for文
  - 多重ループ
  - 多次元配列
  - 参照
  - 再帰関数
  - 計算量
- 第3章:競技プログラミングに役立つ知識
  - 数値型
  - pair/tupleとauto
  - STLのコンテナ(標準テンプレートライブラリ)
  - 構造体
  - ビット演算
  - その他の有用な機能
- 第4章:今まで説明していなかったこと
  - includeディレクティブ
  - 名前空間
  - テンプレート
  - イテレータ
  - ポインタ

## 第1章:基本文法

### 出力とコメント

#### C++プログラムの基本構造

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    // プログラムの内容
    return 0;
}
```

- `#include <bits/stdc++.h>`: C++の機能を全て読み込む
- `using namespace std;`: 標準ライブラリの機能を簡潔に使用可能にする
- `main()関数`: プログラムの実行開始点

#### 出力

- `cout`: 出力のための機能
- `<<`: データを`cout`に送る演算子
- `endl`: 改行を表す
- 文字列は`""`で囲む
- 数値は直接記述可能

```cpp
cout << "Hello, world!" << endl;
cout << 2525 << endl;
```

#### コメント

- `//`: 行末までコメント
- `/* */`: 複数行コメント

#### 注意点

- セミコロン(`;`)で文を終了
- 基本的に半角文字を使用(全角文字はエラーの原因になりうる)
- 文字列内とコメント内では全角文字使用可能

#### 複数の出力

```cpp
cout << "a" << "b" << endl; // "ab"と出力
cout << "c";
cout << "d" << endl; // "cd"と出力
```

#### コメントアウト

一時的にコードを無効化するテクニック。

```cpp
// cout << "This line will not be executed" << endl;
```

### プログラムの書き方

#### スペースと改行

- C++では基本的にスペースと改行は同じ意味
- 多くの場合省略可能
- 読みやすさのために適切に使用することが推奨される

#### インデント

- 行頭の連続したスペース
- プログラムの動作には影響しないが、可読性を高める
- 基本的に`{`の後でインデントを増やし、`}`の後で戻す
- 長い行は改行してインデントすることもある

### プログラムのエラー

- コンパイルエラー
  - 文法のエラー
  - プログラムは実行されない
  - 例：全角文字の混入、セミコロン忘れ
- 実行時エラー
  - プログラムの内容に致命的な間違いがある場合に発生
  - エラーが発生するまでプログラムは動作する
  - 例：0での除算
- 論理エラー
  - プログラムは動作するが、結果が意図したものと異なる
  - 発見が難しい
  - 例：計算式の間違い

#### エラーの修正方法

- 実行して確認→修正→再実行の繰り返し
- エラーメッセージをWeb検索
- わからない場合は他者に質問

#### コンパイルエラーの例

- 全角スペース
  - エラーメッセージに`stray '\343' in program`などが表示される
  - エラー箇所は`./Main.cpp:行:文字目: error`で特定可能
- セミコロン忘れ
  - エラーメッセージに`expected ';' before...`が表示される
  - エラー箇所はメッセージが示す次の行を確認

#### 大量のエラー・謎のエラー

- 一つのミスで多数のエラーメッセージが出ることがある
- 最初のエラーメッセージを確認し、原因を推測する

### 四則演算と優先順位

#### 基本的な算術演算子

| 演算子 | 計算内容 |
|--------|----------|
| `+`    | 足し算   |
| `-`    | 引き算   |
| `*`    | 掛け算   |
| `/`    | 割り算   |
| `%`    | 剰余     |

#### 四則演算

- 整数同士の計算が可能
- 負の値も扱える
- 整数同士の割り算は小数点以下切り捨て
- 小数点以下を扱うには`.0`をつける（例：`7.0 / 3.0`）

#### 剰余演算

- `%`演算子で割り算の余りを計算
- 例：`7 % 3` は `1`

#### 演算子の優先順位

1. `*`, `/`, `%` （高）
2. `+`, `-` （低）

※ `()`を使って優先順位を変更可能

#### 注意点

- 除算の順序
  - 整数同士の割り算では、計算順序によって結果が異なる場合がある
  - 例：`3 / 2 * 4` ≠ `3 * 4 / 2`
  - 割り算はできるだけ後の方で行うのが望ましい
- ゼロ除算
  - 0で割ると実行時エラーが発生
  - `0 / 3`や`0 % 3`は問題なく計算可能（結果は0）

#### 負の数の剰余

- `A % B`の結果は`A`の正負と一致
- `|A|, |B|`を絶対値とすると
  - `A`が正：`|A| % |B|`
  - `A`が負：`-(|A| % |B|)`

### 変数と型

#### 変数の基本概念

- 変数は「メモ」として機能
- データを保存し、後で使用するために名前を付ける

#### 変数の宣言と初期化

```cpp
int name;  // 宣言
name = 10; // 代入
int value = 20; // 宣言と初期化を同時に行う
```

#### 主要な型

| 型      | データの種類 |
|---------|--------------|
| int     | 整数         |
| double  | 小数（実数） |
| string  | 文字列       |

```cpp
int i = 10;
double d = 0.5;
string s = "Hello";
```

#### 変数の操作

- 変数間のコピー
- 演算での使用

```cpp
int a = 10;
int b = a;  // aの値がbにコピーされる
a = 5;      // aの値が変更されてもbは影響を受けない
```

#### 変数名のルール

- 数字で始まらない
- `_`以外の記号は使用不可
- キーワードは使用不可
- 同じ名前の変数を複数回宣言不可

#### 型変換

- 異なる型同士の計算時に自動的に行われる
- int型とdouble型の計算結果はdouble型になる
- 変換できない型同士の計算・代入はコンパイルエラー

```cpp
int i = 30;
double d = 1.5;
cout << i + d << endl; // 31.5
```

#### 注意点

- 初期化前の変数の値は不定
- string型は自動的に空文字列で初期化される

```cpp
int uninitializedVar;
cout << uninitializedVar << endl; // 値は不定
```

### プログラムの実行順序と入力

#### プログラムの実行順序

- プログラムは基本的に上から下へ順番に実行される
- 変数の値は上書きされると変更される

#### 入力の基本

- `cin >> 変数` で入力を受け取る
- 入力はスペースと改行で区切られる

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int a;
    cin >> a;
    cout << a * 10 << endl;
}
```

#### 異なる型のデータ入力

- データの種類に合わせた型の変数を使用する

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string text;
    double d;
    cin >> text >> d;
    cout << text << ", " << d << endl;
}
```

#### 複数の入力

- `cin` を `>>` で繋げて複数の入力を受け取れる
- 入力はスペースか改行で区切る

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int a, b, c;
    cin >> a >> b >> c;
    cout << a * b * c << endl;
}
```

#### 注意点

- `cout` は `<<` でデータを送り、`cin` は `>>` でデータを受け取る
- 入力の順序と変数の順序を合わせる必要がある

### if文、比較演算子、論理演算子

#### if文の基本

- 条件が真の時のみ処理を実行
- 構文: `if (条件式) { 処理 }`

```cpp
if (x < 10) {
    cout << "xは10より小さい" << endl;
}
```

#### 比較演算子

| 演算子 | 意味 |
|--------|------|
| `==`   | 等しい |
| `!=`   | 等しくない |
| `>`    | より大きい |
| `<`    | より小さい |
| `>=`   | 以上 |
| `<=`   | 以下 |

#### 論理演算子

| 演算子 | 意味 | 真になる条件 |
|--------|------|--------------|
| `!`    | 否定 | 条件式が偽 |
| `&&`   | AND  | 両方の条件式が真 |
| `\|\|`   | OR   | 少なくとも一方が真 |

#### 演算子の優先順位

1. `!` (最高)
2. `<`, `<=`, `>`, `>=`
3. `==`, `!=`
4. `&&`
5. `||` (最低)

括弧 `()` を使用して優先順位を明示的に指定することができる。

#### else ifとelse

- else if: 前のif文が偽で、新しい条件が真の時に実行
- else: if文の条件が偽の時に実行

```cpp
if (x < 10) {
    cout << "xは10より小さい" << endl;
} else if (x < 20) {
    cout << "xは10以上20未満" << endl;
} else {
    cout << "xは20以上" << endl;
}
```

#### 注意点

- `==`と`=`の混同に注意
- if文のネストが可能
- 処理が1文の場合、`{}`を省略可能

#### 文字列の比較

文字列(string型)も比較演算子を使用して比較できる。

```cpp
string s = "hello";
if (s == "hello") {
    cout << "sはhelloです" << endl;
}
if (s < "world") {
    cout << "sはworldより辞書順で前です" << endl;
}
```

#### 条件演算子(三項演算子)

簡単なif-else文を1行で書くための演算子。

```cpp
int x = 10;
int y = (x > 5) ? 1 : 0;  // xが5より大きければ1、そうでなければ0
```

#### 条件式の型

- 条件式は`bool`型（真理値型）と呼ばれる
- `true`（真）または`false`（偽）のいずれかの値を持つ

```cpp
bool ok = true;
if (ok) {
    cout << "okはtrueです" << endl;
}
```

#### 暗黙の型変換

- 0は`false`、0以外の数値は`true`として扱われる

```cpp
int x = 1;
if (x) {
    cout << "この行は実行されます" << endl;
}
```

#### 比較演算子の連続使用

- `0 <= x <= 10`のような数学的な表現は、C++では正しく動作しない
- 代わりに `0 <= x && x <= 10` と書く必要がある

```cpp
int x = 5;
if (0 <= x && x <= 10) {
    cout << "xは0以上10以下です" << endl;
}
```

#### 短絡評価(Short-circuit evaluation)

論理演算子 `&&` と `||` は短絡評価を行う。

- `&&`: 左側の式が`false`の場合、右側は評価されない
- `||`: 左側の式が`true`の場合、右側は評価されない

```cpp
int x = 5;
if (x > 0 && (10 / x) > 1) {
    cout << "条件を満たします" << endl;
}
// xが0以下の場合、10/xは評価されないので、0除算エラーを回避できる
```

#### switch文

多数の条件分岐がある場合、switch文を使用すると可読性が向上することがある。

```cpp
int day = 3;
switch (day) {
    case 1:
        cout << "月曜日" << endl;
        break;
    case 2:
        cout << "火曜日" << endl;
        break;
    case 3:
        cout << "水曜日" << endl;
        break;
    // ... 他の曜日 ...
    default:
        cout << "無効な日付" << endl;
}
```

#### 条件式の結果を変数に格納

条件式の結果を直接bool型の変数に格納できる。

```cpp
int x = 10;
bool is_positive = (x > 0);
if (is_positive) {
    cout << "xは正の数です" << endl;
}
```

#### 複合条件の括弧の使用

複雑な条件式では、括弧を使用して優先順位を明確にすることが推奨される。

```cpp
if ((a < b && c < d) || (e < f && g < h)) {
    cout << "条件を満たします" << endl;
}
```

#### ネストされたif文の扱い

if文を多重にネストすると、コードの可読性が低下する。可能な限りネストを減らす工夫をすること。

```cpp
// ネストが深い例
if (condition1) {
    if (condition2) {
        if (condition3) {
            // 処理
        }
    }
}

// 改善例
if (!condition1 || !condition2 || !condition3) {
    return; // 早期リターン
}
// 処理
```

#### ガード節

条件を満たさない場合に早期リターンする方法で、コードの可読性を向上させる。

```cpp
if (error_condition) {
    // エラー処理
    return;
}
// 正常な処理
```

#### 条件演算子のネスト

条件演算子(三項演算子)をネストすることで、複数の条件分岐を1行で書くことができるが、可読性に注意が必要。

```cpp
int x = 10;
string result = (x < 0) ? "負" : (x > 0) ? "正" : "ゼロ";
cout << result << endl;
```

### 条件式の結果とbool型

#### 条件式の結果

- 真の場合: 数値の`1`で表現
- 偽の場合: 数値の`0`で表現

```cpp
cout << (5 < 10) << endl; // 出力: 1 (真)
cout << (5 > 10) << endl; // 出力: 0 (偽)
```

#### trueとfalse

- `true`: 真を表す予約語
- `false`: 偽を表す予約語

```cpp
if (true) {
    cout << "hello" << endl; // 実行される
}
if (false) {
    cout << "world" << endl; // 実行されない
}
```

#### bool型

- `true`または`false`のみを格納できる型
- 条件式の結果や2つの状態を持つものを表現するのに適している

```cpp
bool a = true;
bool b = x < 10; // xが10未満ならtrue、そうでなければfalse
```

#### 真偽値の表現方法

| int型の表現 | bool型の表現 |
|-------------|--------------|
| 真 | 1 | true |
| 偽 | 0 | false |

#### bool型と数値の関係

- `0`は`false`として扱われる
- `0`以外の数値は全て`true`として扱われる

```cpp
bool a = 10; // true
bool b = 0;  // false
```

#### 注意点

- `==`と`=`の書き間違いに注意
- `if (a = b)`は`if (b != 0)`とほぼ同じ意味になってしまう

### 変数のスコープ

#### キーポイント

- `{}`で囲まれた部分を**ブロック**という
- 変数が使える範囲を**スコープ**という
- 変数のスコープは「変数が宣言されてからそのブロックが終わるまで」
- スコープが重なる場合、最も内側のブロックで宣言された変数が選ばれる

#### 変数のスコープ

- ブロック内で宣言された変数は、そのブロックとそれより内側のブロックでのみ使用可能
- 変数のスコープは宣言された行からブロックの終わりまで

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int x = 5; // xのスコープはここからmain関数の終わりまで
    if (x == 5) {
        int y = 10; // yのスコープはここからif文の終わりまで
        cout << x + y << endl; // 正常に動作
    }
    cout << x << endl; // 正常に動作
    // cout << y << endl; // エラー: yはこのスコープで宣言されていない
}
```

#### 同じ名前の変数

- 異なるブロックであれば、同じ名前の変数を宣言可能

```cpp
int main() {
    int x = 10;
    if (x == 5) {
        int y = 10;
        // string y = "hello"; // エラー: 同じブロックに変数yがすでにある
    }
    if (x == 10) {
        string y = "hello"; // OK: 異なるブロックなので宣言可能
        cout << x << y << endl;
    }
}
```

#### スコープが重なっている場合

- 変数を使用できる条件
  - 使用箇所より前で宣言されている
  - 同じか外側のブロックで宣言されている
- 同名の変数のスコープが重なる場合、最も内側で宣言された変数が選ばれる

```cpp
int main() {
    int x = 5;
    cout << x << endl; // 5
    if (x == 5) {
        cout << x << endl; // 5
        string x = "hello";
        cout << x << endl; // hello
    }
    cout << x << endl; // 5
}
```

#### スコープの重要性

- プログラムの異なる部分で同じ変数名を再利用可能
- 大規模なプログラムでの変数名の管理を容易にする

### 複合代入演算子

- 同じ変数名が2回現れる代入文を短く書くための演算子
- 例：`x += 1 + 2;` は `x = x + (1 + 2);` と同じ意味
- `x += 1` は `x++` と書ける(インクリメント)
- `x -= 1` は `x--` と書ける(デクリメント)

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int x = 5;
    x += 1 + 2;
    cout << x << endl; // 8
}
```

#### 他の複合代入演算子

- `-=`, `*=`, `/=`, `%=` なども同様に使用可能

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int a = 5;
    a -= 2;
    cout << a << endl; // 3

    int b = 3;
    b *= 1 + 2;
    cout << b << endl; // 9

    int c = 4;
    c /= 2;
    cout << c << endl; // 2

    int d = 5;
    d %= 2;
    cout << d << endl; // 1
}
```

#### インクリメントとデクリメント

- インクリメント（1増やす）: `x++` または `++x`
- デクリメント（1減らす）: `x--` または `--x`

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int x = 5;
    x++;
    cout << x << endl; // 6

    int y = 5;
    y--;
    cout << y << endl; // 4
}
```

#### シンタックスシュガー

- これらのプログラムを短く書くための記法を「シンタックスシュガー」と呼ぶ

### while文

#### while文の基本

- 条件式が真の間、処理を繰り返す
- 構文: `while (条件式) { 処理 }`

```cpp
while (true) {
    cout << "Hello" << endl;
    cout << "AtCoder" << endl;
}
```

#### カウンタを使用したループ

- 変数を使って繰り返し回数を制御する

```cpp
int i = 1;
while (i <= 5) {
    cout << i << endl;
    i++;
}
```

#### 推奨されるループの書き方

- カウンタ変数は0から始め、N未満でループする

```cpp
int N = 5;
int i = 0;
while (i < N) {
    cout << "Hello" << endl;
    i++;
}
```

#### 応用例:合計値の計算

```cpp
int N;
cin >> N;
int sum = 0;
int x;
int i = 0;
while (i < N) {
    cin >> x;
    sum += x;
    i++;
}
cout << sum << endl;
```

#### 応用例:2ずつ増加

```cpp
int i = 0;
while (i < 10) {
    cout << i << endl;
    i += 2;
}
```

#### 応用例:逆順ループ

```cpp
int i = 5;
while (i >= 0) {
    cout << i << endl;
    i--;
}
```

#### 注意点

- 無限ループに注意(AtCoderでは実行時間制限あり)
- カウンタ変数の名前は通常`i`, `j`, `k`の順で使用

### for文、break、continue

#### for文の基本

- 繰り返し処理を簡潔に書くための構文
- 構文: `for (初期化; 条件式; 更新) { 処理 }`

```cpp
for (int i = 0; i < 3; i++) {
    cout << "Hello for: " << i << endl;
}
```

#### N回の繰り返し処理

- 一般的なパターン: `for (int i = 0; i < N; i++) { 処理 }`

```cpp
int N = 5;
for (int i = 0; i < N; i++) {
    cout << i << endl;
}
```

#### break文

- ループを途中で抜けるための命令

```cpp
for (int i = 0; i < 5; i++) {
    if (i == 3) {
        cout << "ぬける" << endl;
        break;
    }
    cout << i << endl;
}
```

#### continue文

- 後の処理をとばして次のループへ行くための命令

```cpp
for (int i = 0; i < 5; i++) {
    if (i == 3) {
        cout << "とばす" << endl;
        continue;
    }
    cout << i << endl;
}
```

#### for文とwhile文の違い

- カウンタ変数のスコープ: for文の方が狭い
- continueの動作: while文では更新処理を飛ばす可能性がある

#### for文の応用

- 省略形: `for (; 条件式;) { 処理 }`
- 無限ループ: `for (;;) { 処理 }`
- 多重ループ(ネスト)

```cpp
for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 2; j++) {
        cout << "i: " << i << ", j:" << j << endl;
    }
}
```

#### コツと注意点

- for文は主に「決まった回数の繰り返し」に使用
- while文は主に「条件が満たされる間の繰り返し」に使用
- break文とcontinue文は適切に使用することで、コードの可読性と効率を向上させる
- 無限ループに注意(特にwhile文やcontinueを使用する際)

### 文字列と文字

#### 文字列(string型)

- 文字が順番に並んだもの
- string型を使用して扱う

```cpp
string str1, str2;
cin >> str1;
str2 = ", world!";
cout << str1 << str2 << endl;
```

#### 文字列の長さ

- `文字列変数.size()`で取得

```cpp
string str = "Hello";
cout << str.size() << endl; // 5
```

#### 文字列の要素へのアクセス

- `文字列変数.at(i)`でi番目の文字にアクセス
- 添字は0から始まる

```cpp
string str = "hello";
cout << str.at(0) << endl; // h
cout << str.at(4) << endl; // o
```

#### 文字(char型)

- 一文字のデータを保持
- シングルクォーテーション（'）で囲む

```cpp
char c = 'a';
cout << c << endl; // a
```

#### 文字列と文字の関係

- `文字列変数.at(i)`はchar型を返す

```cpp
string str = "Hello";
char c = str.at(0);
cout << c << endl; // H
```

#### 文字列の操作

- 書き換え
- 比較

書き換えの例。

```cpp
string str = "Hello";
str.at(0) = 'M';
cout << str << endl; // Mello
```

比較の例。

```cpp
if (str.at(1) == 'e') {
    cout << "AtCoder" << endl;
}
```

#### ループとの組み合わせ

```cpp
string str;
cin >> str;
int count = 0;
for (int i = 0; i < str.size(); i++) {
    if (str.at(i) == 'O') {
        count++;
    }
}
cout << count << endl;
```

#### 注意点

- 添字が範囲外の場合、実行時エラーが発生
- 全角文字は正しく扱えない
- 文字列のメンバ関数使用時は変数に格納するか、リテラルの末尾に's'をつける

```cpp
cout << "Hello"s.size() << endl; // 5
```

#### 文字列の比較

- string型には比較演算子（==, !=, <, <=, >, >=）が定義されている
- 辞書順で比較される（'0'~'9' → 'A'~'Z' → 'a'~'z'）

```cpp
string s1 = "ABC";
string s2 = "XY";
if (s1 < s2) {
    cout << "ABC < XY" << endl;
}
```

#### 文字列の連結

- `+`演算子で文字列を連結できる
- `+=`演算子も使用可能

```cpp
string hello = "Hello";
cout << hello + ", world!" << endl;
hello += ", AtCoder!";
```

#### stringとcharの比較と連結

- string型とchar型は`==`で直接比較できない
- string型とchar型は`+`で連結可能

```cpp
string str = "Hello";
char c = str.at(0);
cout << str + c << endl; // HelloH
```

#### char型の変数への入力

- cinでchar型変数に入力すると、一文字ずつ取り出せる

```cpp
char a, b;
cin >> a >> b;
```

#### エスケープシーケンス

- 特殊な文字を表現するための記法
- 主なエスケープシーケンス：
  - `\n`: 改行
  - `\"`: 二重引用符
  - `\'`: 引用符
  - `\\`: バックスラッシュ
  - `\t`: タブ
  - `\r`: 復帰

```cpp
cout << "こんにちは\nAtCoder";
```

#### 行単位での入力

- `getline(cin, 変数名)`で行単位の入力が可能
- 空白を含む文字列の入力に使用

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    cout << s << endl;
}
```

- 注意点
  - `cin >> 変数名`の後に`getline`を使用する場合、間に`cin.ignore()`を挿入する必要がある
  - これは`cin`が改行を読み飛ばさないため

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s, t;
    cin >> s;
    cin.ignore(); // この行を追加
    getline(cin, t);
    cout << s << endl;
    cout << t << endl;
}
```

#### 文字列の分割

- `stringstream`を使用して文字列を分割できる

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s = "Hello AtCoder";
    stringstream ss(s);
    string word;
    while (ss >> word) {
        cout << word << endl;
    }
}
```

#### 文字列から数値への変換

- `stoi(文字列)`：文字列をint型に変換
- `stoll(文字列)`：文字列をlong long型に変換
- `stod(文字列)`：文字列をdouble型に変換

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s = "100";
    int x = stoi(s);
    cout << x + 1 << endl; // 101
}
```

### 配列

#### 配列の基本

- 配列は様々なデータの列を扱う機能
- 宣言: `vector<型> 配列変数名;`
- 初期化: `配列変数名 = { 要素1, 要素2, ... };`

```cpp
vector<int> vec;
vec = {25, 100, 64};
```

#### 配列の要素へのアクセス

- `配列変数.at(i)`: i番目の要素にアクセス
- 添字は0から始まる

```cpp
cout << vec.at(0) << endl; // 25
```

#### 配列の大きさ

- `配列変数.size()`: 配列の要素数を取得

```cpp
cout << vec.size() << endl; // 3
```

#### 配列の初期化

- `vector<型> 配列変数名(要素数)`: 指定した要素数で初期化

```cpp
vector<int> vec(3); // {0, 0, 0}
```

#### 配列への入力

- for文を使用して入力を受け取る

```cpp
int N;
cin >> N;
vector<int> vec(N);
for (int i = 0; i < N; i++) {
    cin >> vec.at(i);
}
```

#### 配列の応用

- 複数の変数を一度に扱える
- for文と組み合わせて大量のデータを処理

```cpp
vector<int> math(N), english(N);
for (int i = 0; i < N; i++) {
    cin >> math.at(i);
}
for (int i = 0; i < N; i++) {
    cin >> english.at(i);
}
for (int i = 0; i < N; i++) {
    cout << math.at(i) + english.at(i) << endl;
}
```

#### その他の機能

- 初期値の指定: `vector<型> 配列名(要素数, 初期値);`
- 要素の追加: `配列変数.push_back(値);`

```cpp
vector<int> vec(3, 5); // {5, 5, 5}
vec.push_back(10); // {5, 5, 5, 10}
```

#### 注意点

- 範囲外アクセスに注意
- `at()`を使用することで範囲外アクセス時にエラーメッセージを得られる

#### vector以外の配列

C++には3種類の主な配列の宣言方法がある。

1. vectorによる配列: `vector<int> data(3);`
2. Cの配列: `int data;`
3. arrayによる配列: `array<int, 3> data;`

#### 注意点

- Cの配列は落とし穴が多いため、基本的にはvectorを使用することが推奨される
- AtCoderの模範解答ではCの配列が使われることもあるため、両方の記法を理解しておくことが有用

#### atを使わないアクセス方法

- `配列変数[添字]`でも要素にアクセス可能
- しかし、この方法は範囲外アクセス時にエラーメッセージを表示しない
- デバッグの容易さから、`配列変数.at(添字)`の使用が推奨される

```cpp
vector<int> vec = {1, 2, 3};
cout << vec[0] << endl; // 1 (atを使わないアクセス)
cout << vec.at(0) << endl; // 1 (atを使うアクセス)
```

#### 配列の初期化方法

複数の初期化方法が存在する。

1. 要素を直接指定: `vector<int> vec = {1, 2, 3};`
2. サイズと初期値を指定: `vector<int> vec(3, 0);` // {0, 0, 0}
3. サイズのみ指定（デフォルト値で初期化）: `vector<int> vec(3);` // {0, 0, 0}

#### 多次元配列

- vectorを入れ子にすることで多次元配列を作成可能

```cpp
vector<vector<int>> vec(3, vector<int>(4));
```

これは3行4列の2次元配列を作成する。

### 組み込み関数(STL)

#### STLの関数の基本

- STL(Standard Template Library): C++で用意されている関数等のまとまり
- 関数呼び出し: `関数名(引数1, 引数2, ...)`
- 引数: 関数に渡す値
- 返り値（戻り値）: 関数の計算結果

#### 主要なSTL関数

##### min関数

- 機能: 2つの引数のうち小さい方の値を返す

```cpp
int answer = min(10, 5);
cout << answer << endl; // 5
```

##### max関数

- 機能: 2つの引数のうち大きい方の値を返す

```cpp
int answer = max(10, 5);
cout << answer << endl; // 10
```

##### swap関数

- 機能: 2つの引数の値を交換する

```cpp
int a = 10, b = 5;
swap(a, b);
cout << a << " " << b << endl; // 5 10
```

#### 配列を引数にする関数

##### reverse関数

- 機能: 配列の要素の並びを逆にする

```cpp
vector<int> vec = {1, 5, 3};
reverse(vec.begin(), vec.end());
// vec は {3, 5, 1} になる
```

##### sort関数

- 機能: 配列の要素を小さい順に並び替える

```cpp
vector<int> vec = {2, 5, 2, 1};
sort(vec.begin(), vec.end());
// vec は {1, 2, 2, 5} になる
```

#### 注意点

- 引数と返り値の型は関数によって決まっている
- 型が合わないとコンパイルエラーになる
- 配列を引数にする関数は特殊な形式で呼び出す: `関数名(配列変数.begin(), 配列変数.end())`

#### 応用

- sort関数とreverse関数を組み合わせて大きい順にソート

```cpp
vector<int> vec = {2, 5, 2, 1};
sort(vec.begin(), vec.end());
reverse(vec.begin(), vec.end());
// vec は {5, 2, 2, 1} になる
```

#### 引数で関数を呼び出した場合の実行順序

- 関数の引数として別の関数を呼び出す場合、内側の関数から実行される

```cpp
min(max(1, 2), 3)
```

- 実行順序
  1. `max(1, 2)` が実行され、結果は2
  2. `min(2, 3)` が実行され、最終結果は2

#### 引数の実行順序

- 引数の実行順序は環境によって異なる
- APG4bの推奨環境（GCC, C++）では、最後の引数の式から順に実行される

```cpp
min(1 + 1, 2 + 2)
```

- GCCでの実行順序
  1. `2 + 2` が実行され、4になる
  2. `1 + 1` が実行され、2になる
  3. `min(2, 4)` が実行され、最終結果は2
- 他の環境(Clang等)では、最初の引数の式から順に実行されることがある

- Clangでの実行順序
  1. `1 + 1` が実行され、2になる
  2. `2 + 2` が実行され、4になる
  3. `min(2, 4)` が実行され、最終結果は2

#### 注意点

- この挙動の違いが問題になるケースは少ないが、自作関数を定義する際には注意が必要
- 環境依存の挙動に頼らないコーディングが推奨される

### 関数の定義と使用

#### 関数の定義

- 構文: `返り値の型 関数名(引数1の型 引数1の名前, 引数2の型 引数2の名前,...) { 処理 }`

```cpp
int my_min(int x, int y) {
    if (x < y) {
        return x;
    } else {
        return y;
    }
}
```

#### 返り値の指定

- `return 返り値;` で指定
- 返り値がない場合は `void` を使用し、`return;` と書く

#### 引数がない関数

- `()` だけを書く

```cpp
int input() {
    int x;
    cin >> x;
    return x;
}
```

#### 関数の動作

- 関数呼び出し時に引数の値がコピーされる
- return文に到達すると関数の処理が終了する

#### 注意点

- 返り値の指定忘れに注意（未定義の値が返る可能性）
- 引数はコピーされるため、関数内での変更は呼び出し元に影響しない

#### 関数が呼び出せる範囲

- 関数は宣言した行より後でしか呼び出せない
- プロトタイプ宣言を使用すると、定義前に呼び出し可能

#### その他の機能

- 関数のオーバーロード：同じ名前で異なる引数の関数を定義可能
- main関数：特別な関数で、returnを省略すると0を返す

#### 変数のスコープ

- 関数内の変数は、その関数内でのみ有効

#### サンプルコード

```cpp
#include <bits/stdc++.h>
using namespace std;

int my_min(int x, int y) {
    if (x < y) {
        return x;
    } else {
        return y;
    }
}

void hello(string text) {
    cout << "Hello, " << text << endl;
}

int main() {
    int answer = my_min(10, 5);
    cout << answer << endl;  // 5

    hello("C++");  // Hello, C++

    return 0;
}
```

#### プロトタイプ宣言

- 関数を定義する前に呼び出すためのテクニック
- 構文: `返り値の型 関数名(引数1の型, 引数2の型, ...);`
- 引数名は省略可能

```cpp
void hello(); // プロトタイプ宣言
int main() {
    hello(); // プロトタイプ宣言により呼び出し可能
}
void hello() {
    cout << "hello!" << endl;
}
```

#### returnの省略

- 返り値がない関数（void型）では、関数末尾のreturnを省略可能

#### main関数の特殊性

- returnを省略した場合、自動的に0が返される

#### 関数のオーバーロード

- 同じ名前で異なる引数の型や数の関数を定義可能
- 返り値の型だけが異なる場合はオーバーロードできない

```cpp
int my_min(int x, int y) { /* ... */ }
int my_min(int x, int y, int z) { /* ... */ }
```

#### 複雑な引数の条件指定

- テンプレートを使用することで、より柔軟な引数の条件指定が可能
- 例：「大小比較ができる型なら何でも良い」など

#### 変数のスコープ

- 関数内の変数は、その関数のスコープ内でのみ有効
- 同じ名前の変数でも、異なる関数内では別の変数として扱われる

```cpp
void test() {
    int num = 5;
    cout << num << endl; // 5
}
int main() {
    int num = 10;
    test();
    cout << num << endl; // 10
}
```

## 参考

- [AtCoder Programming Guide for beginners (APG4b)](https://atcoder.jp/contests/APG4b)